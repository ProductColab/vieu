/* eslint-disable @typescript-eslint/no-unused-vars */

import * as z from "zod";
import React from "react";
import type { BaseMetadata, ViewRegistry } from "./base.registry";

/**
 * Props for the schema field renderer component
 * @template T - The metadata type extending BaseMetadata
 */
export interface SchemaFieldRendererProps {
  /** The Zod schema for the field */
  schema: z.ZodType;
  /** The name of the field */
  fieldName: string;
  /** The current value of the field */
  value: unknown;
  /** Optional CSS class name */
  className?: string;
  /** Additional props to pass to the rendered component */
  [key: string]: unknown;
}

/**
 * Return type for the schema field renderer factory
 * @template T - The metadata type extending BaseMetadata
 */
export type SchemaFieldRenderer<T extends BaseMetadata> =
  React.ComponentType<SchemaFieldRendererProps>;

/**
 * Creates a schema field renderer component that works with any registry
 * @template T - The metadata type extending BaseMetadata
 * @param registry - The view registry to use for rendering
 * @returns A React component that can render schema fields
 *
 * @example
 * ```typescript
 * const FieldRenderer = createSchemaFieldRenderer(myRegistry);
 *
 * <FieldRenderer
 *   schema={stringSchema}
 *   fieldName="username"
 *   value="john_doe"
 *   className="form-field"
 * />
 * ```
 */
export function createSchemaFieldRenderer<T extends BaseMetadata>(
  registry: ViewRegistry<T>
): SchemaFieldRenderer<T> {
  return ({
    schema,
    fieldName,
    value,
    className,
    ...extraProps
  }: SchemaFieldRendererProps) => {
    const metadata = registry.get(schema);

    if (!metadata) {
      return React.createElement(
        "div",
        { className: "text-red-500 text-sm" },
        `No metadata found for field: ${fieldName}`
      );
    }

    // Pass all extra props to the render function
    return registry.render(
      schema,
      metadata,
      value,
      fieldName,
      className,
      extraProps
    );
  };
}

/**
 * Callback function type for schema shape iteration
 */
export type SchemaShapeCallback = (
  fieldName: string,
  fieldSchema: z.ZodType
) => React.ReactElement;

/**
 * Iterates over a schema's shape and applies a callback to each field
 * @param schema - The Zod schema to iterate over
 * @param callback - Function to call for each field in the schema
 * @returns Array of React elements generated by the callback
 *
 * @example
 * ```typescript
 * const fields = iterateSchemaShape(userSchema, (fieldName, fieldSchema) => (
 *   <div key={fieldName}>
 *     <label>{fieldName}</label>
 *     <FieldRenderer schema={fieldSchema} fieldName={fieldName} value={data[fieldName]} />
 *   </div>
 * ));
 * ```
 */
export function iterateSchemaShape(
  schema: z.ZodType,
  callback: SchemaShapeCallback
): React.ReactElement[] {
  if (!("shape" in schema)) {
    return [
      React.createElement(
        "div",
        { key: "error", className: "text-red-500" },
        "Schema does not have shape property"
      ),
    ];
  }

  const shape = schema.shape as Record<string, z.ZodType>;
  return Object.entries(shape).map(([fieldName, fieldSchema]) =>
    callback(fieldName, fieldSchema)
  );
}

/**
 * Result type for schema data extraction
 */
export interface SchemaDataExtractionResult {
  /** The validated data, or null if validation failed */
  data: unknown;
  /** Map of field names to error messages */
  errors: Record<string, string>;
}

/**
 * Extracts and validates data from form data using a Zod schema
 * @param schema - The Zod schema to validate against
 * @param formData - The form data to validate
 * @returns Object containing validated data and any validation errors
 *
 * @example
 * ```typescript
 * const { data, errors } = extractSchemaData(userSchema, formData);
 *
 * if (Object.keys(errors).length === 0) {
 *   // Data is valid, proceed with submission
 *   await submitUser(data);
 * } else {
 *   // Show validation errors
 *   setFormErrors(errors);
 * }
 * ```
 */
export function extractSchemaData(
  schema: z.ZodType,
  formData: Record<string, unknown>
): SchemaDataExtractionResult {
  try {
    const validatedData = schema.parse(formData);
    return { data: validatedData, errors: {} };
  } catch (error) {
    if (error instanceof z.ZodError) {
      const errors: Record<string, string> = {};
      error.issues.forEach((err) => {
        const fieldName = err.path[0];
        errors[fieldName as string] = err.message;
      });
      return { data: null, errors };
    }
    return { data: null, errors: { _general: "Unknown validation error" } };
  }
}

/**
 * Props for the schema wrapper component
 * @template T - The metadata type extending BaseMetadata
 */
export interface SchemaWrapperProps {
  /** The Zod schema to render */
  schema: z.ZodType;
  /** The data object containing field values */
  data: Record<string, unknown>;
  /** Optional render function for custom field rendering */
  children?: (
    fieldName: string,
    fieldSchema: z.ZodType,
    SchemaField: React.ComponentType<SchemaFieldRendererProps>
  ) => React.ReactElement;
  /** Additional props to pass to field components */
  [key: string]: unknown;
}

/**
 * Props for the schema wrapper container
 */
export interface SchemaWrapperContainerProps {
  /** Optional CSS class name for the container */
  className?: string;
  /** Additional props for the container element */
  [key: string]: unknown;
}

/**
 * Return type for the schema wrapper factory
 * @template T - The metadata type extending BaseMetadata
 */
export type SchemaWrapper<T extends BaseMetadata> =
  React.ComponentType<SchemaWrapperProps>;

/**
 * Creates a wrapper component for schema-based rendering
 * @template T - The metadata type extending BaseMetadata
 * @param registry - The view registry to use for rendering
 * @param containerProps - Optional props for the container element
 * @returns A React component that renders all fields in a schema
 *
 * @example
 * ```typescript
 * const SchemaForm = createSchemaWrapper(registry, { className: 'form-container' });
 *
 * <SchemaForm schema={userSchema} data={userData}>
 *   {(fieldName, fieldSchema, SchemaField) => (
 *     <div key={fieldName} className="field-group">
 *       <label>{fieldName}</label>
 *       <SchemaField
 *         schema={fieldSchema}
 *         fieldName={fieldName}
 *         value={userData[fieldName]}
 *       />
 *     </div>
 *   )}
 * </SchemaForm>
 * ```
 */
export function createSchemaWrapper<T extends BaseMetadata>(
  registry: ViewRegistry<T>,
  containerProps?: SchemaWrapperContainerProps
): SchemaWrapper<T> {
  const SchemaField = createSchemaFieldRenderer(registry);

  return ({ schema, data, children, ...extraProps }: SchemaWrapperProps) => {
    const fields = iterateSchemaShape(schema, (fieldName, fieldSchema) => {
      if (children) {
        return children(fieldName, fieldSchema, SchemaField);
      }

      // Default rendering
      return React.createElement(SchemaField, {
        key: fieldName,
        schema: fieldSchema,
        fieldName,
        value: data[fieldName],
        ...extraProps,
      });
    });

    return React.createElement(
      "div",
      {
        className: containerProps?.className,
        ...containerProps,
      },
      ...fields
    );
  };
}

/**
 * Return type for the useSchemaData hook
 * @template T - The data type
 */
export interface UseSchemaDataResult<T> {
  /** Current form data */
  data: Partial<T>;
  /** Current validation errors */
  errors: Record<string, string>;
  /** Function to update a specific field */
  updateField: (fieldName: keyof T, value: T[keyof T]) => void;
  /** Function to validate all data */
  validate: () => SchemaDataExtractionResult;
  /** Function to reset form to initial state */
  reset: () => void;
  /** Function to set all data at once */
  setData: React.Dispatch<React.SetStateAction<Partial<T>>>;
}

/**
 * Hook for managing schema-based form data with validation
 * @template T - The data type
 * @param schema - The Zod schema to validate against
 * @param initialData - Initial data values
 * @returns Object containing data, errors, and management functions
 *
 * @example
 * ```typescript
 * const { data, errors, updateField, validate, reset } = useSchemaData(
 *   userSchema,
 *   { name: '', email: '' }
 * );
 *
 * const handleSubmit = () => {
 *   const { data: validatedData, errors: validationErrors } = validate();
 *
 *   if (Object.keys(validationErrors).length === 0) {
 *     // Submit the form
 *     onSubmit(validatedData);
 *   }
 * };
 * ```
 */
export function useSchemaData<T>(
  schema: z.ZodType,
  initialData: Partial<T> = {}
): UseSchemaDataResult<T> {
  const [data, setData] = React.useState<Partial<T>>(initialData);
  const [errors, setErrors] = React.useState<Record<string, string>>({});

  const updateField = React.useCallback(
    (fieldName: keyof T, value: T[keyof T]) => {
      setData((prev) => ({ ...prev, [fieldName]: value }));

      // Clear error when user starts typing
      if (errors[fieldName as string]) {
        setErrors((prev) => ({ ...prev, [fieldName]: "" }));
      }
    },
    [errors]
  );

  const validate = React.useCallback(() => {
    const result = extractSchemaData(schema, data);
    setErrors(result.errors);
    return result;
  }, [schema, data]);

  const reset = React.useCallback(() => {
    setData(initialData);
    setErrors({});
  }, [initialData]);

  return {
    data,
    errors,
    updateField,
    validate,
    reset,
    setData,
  };
}
